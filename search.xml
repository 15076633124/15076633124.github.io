<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>自我介绍</title>
    <url>/2023/04/18/tags/</url>
    <content><![CDATA[<img src="/images/风筝.jpg" />
一名前端开发工程师，热爱学习，接受新的知识

<p>写博客的目的：<br>    一、记录自己的生活<br>    二、记录学习的知识<br>    三、希望大家能一起学习讨论</p>
]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2023/04/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<img src="/images/git.png"  />
<span id="more"></span>

<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue-的基本原理"><a href="#Vue-的基本原理" class="headerlink" title="Vue 的基本原理"></a>Vue 的基本原理</h3><ul>
<li>当一个 Vue 实例创建的时候，vue 会遍历 data 中的属性，用 Object.defineProperty(Vue3 使用 proxy) 将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得到更新</li>
</ul>
<h3 id="双向数据绑定的原理"><a href="#双向数据绑定的原理" class="headerlink" title="双向数据绑定的原理"></a>双向数据绑定的原理</h3><ul>
<li>Vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</li>
</ul>
<h3 id="slot-是什么？有什么作用？"><a href="#slot-是什么？有什么作用？" class="headerlink" title="slot 是什么？有什么作用？"></a><strong>slot 是什么？有什么作用？</strong></h3><p>slot又可以叫做插槽，插槽可以说是子组件的一个模板标签元素，而这一个标签元素是否显示和怎样显示是由父组件决定的。slot插槽 又分为三种：默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>默认插槽也叫匿名插槽，当slot没有指定 name 属性值的时候默认显示的一个插槽，一个组件内部只能有一个匿名插槽。</li>
<li>具名插槽，顾名思义就是有具体名字的插槽，一个组件可以出现多个具名插槽</li>
<li>作用域插槽既可以是匿名插槽也可以是具名插槽，不同的是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件传递过来的数据决定如何渲染该插槽</li>
</ul>
<h3 id="nexttice作用"><a href="#nexttice作用" class="headerlink" title="nexttice作用"></a>nexttice作用</h3><ul>
<li>比如 DOM1 的数据发生了变化，而 DOM2 需要从 DOM1 中获取数据时，那这时候会发现 DOM2 的视图没有更新，这种情况就需要用到 nexttick。</li>
</ul>
<h3 id="Vue-data-中某一个属性的值发送改变后，视图会立即同步执行重新渲染吗？"><a href="#Vue-data-中某一个属性的值发送改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="Vue data 中某一个属性的值发送改变后，视图会立即同步执行重新渲染吗？"></a>Vue data 中某一个属性的值发送改变后，视图会立即同步执行重新渲染吗？</h3><ul>
<li>不会立即同步执行重新渲染。原因是 Vue 实现响应式并不是数据发送变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要监听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发送的所有数据变更。</li>
</ul>
<h3 id="子组件可以直接改变父组件的数据吗？"><a href="#子组件可以直接改变父组件的数据吗？" class="headerlink" title="子组件可以直接改变父组件的数据吗？"></a>子组件可以直接改变父组件的数据吗？</h3><ul>
<li>子组件不可以直接改变父组件的数据。原因是因为 vue 提倡单向数据流，即父组件 props 的更新会流向子组件，反之不行。这是为了防止意外改变父组件状态，使得应用的数据流变得难以理解，导致数据混乱。如果破坏了单向数据流，应用复杂时，debug成本会非常高</li>
<li>解决方法可以使用 $emit 派发一个自定义事件，父组件接收到后，在进行修改</li>
</ul>
<h3 id="assets-和-static-的区别"><a href="#assets-和-static-的区别" class="headerlink" title="assets 和 static 的区别"></a>assets 和 static 的区别</h3><h4 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h4><ul>
<li>assets 和 static 两个都是存放静态资源的文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下。</li>
</ul>
<h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ul>
<li>assets中存放的静态资源文件在项目打包时，放置的静态资源文件也会进行打包上传，也就是压缩体积，代码进行格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。</li>
<li>static 中放置的静态资源文件就不会走打包压缩格式化流程，而是直接进入打包好的目录，直接上传至服务器。因为 static 中的资源文件没有进行压缩所以文件的体积也相对于 assets 打包后的文件较大点。在服务器中占用更大的空间</li>
</ul>
<h4 id="做项目时静态资源放置位置选择"><a href="#做项目时静态资源放置位置选择" class="headerlink" title="做项目时静态资源放置位置选择"></a>做项目时静态资源放置位置选择</h4><ul>
<li>将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包流程。减少体积。而项目引入的第三方资源文件 如 icon.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，不需要处理，直接上传。</li>
</ul>
<h3 id="delete-和-Vue-delete-删除数组的区别？"><a href="#delete-和-Vue-delete-删除数组的区别？" class="headerlink" title="delete 和 Vue.delete 删除数组的区别？"></a>delete 和 Vue.delete 删除数组的区别？</h3><ul>
<li><p>delete 只是被删除的元素变成了 empty&#x2F;undefined 其他的元素的键值不变</p>
</li>
<li><p>Vue.delete 是直接删除了数组，改变了数组的键值。</p>
</li>
</ul>
<h3 id="v-if-和-v-for-哪个优先级更高？如果同时出现，应如何优化？"><a href="#v-if-和-v-for-哪个优先级更高？如果同时出现，应如何优化？" class="headerlink" title="v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优化？"></a>v-if 和 v-for 哪个优先级更高？如果同时出现，应如何优化？</h3><ul>
<li>v-for的优先级高于v-if，如果同时出现，每次渲染都会先执行循环再判断条件，无论如何循环都不可避免，浪费性能。</li>
<li>避免的话可以再外层嵌套 template，在这一层进行 v-if 判断，然后在内部进行 v-for 循环。如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项</li>
</ul>
<h3 id="对-Vue-组件化的理解"><a href="#对-Vue-组件化的理解" class="headerlink" title="对 Vue 组件化的理解"></a>对 Vue 组件化的理解</h3><ol>
<li>组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独立和通用可复用的组织构建大型应用；</li>
<li>组件化开发能大幅提示应用开发效率、测试性、复用性等；</li>
<li>组件使用按分类有：页面组件、业务组件、通用组件</li>
<li>vue 的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函数，它们基于 VueComponent，扩展于 Vue;</li>
<li>vue 中常见组件化技术有：属性 prop，自定义事件，插槽等。它们主要用于组件通信、扩展等；</li>
<li>合理的划分组件可以提升应用性能</li>
<li>组件应该是高内聚低耦合的</li>
<li>遵循单向数据流的原则</li>
</ol>
<h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><ul>
<li>beforeCreate(创建前) → created(创建后) → beforeMount(挂载前) → mounted(挂载后) → beforeUpdate(更新前) → updated(更新后) → beforeDestroy(销毁前) → destroyed(销毁后)</li>
<li>另外还有一个 keep-alive 独有的生命周期，分别为 activated 和 deactivated。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 activated 钩子函数</li>
</ul>
<h4 id="Vue-子组件和父组件执行顺序"><a href="#Vue-子组件和父组件执行顺序" class="headerlink" title="Vue 子组件和父组件执行顺序"></a>Vue 子组件和父组件执行顺序</h4><p>加载渲染过程：</p>
<ul>
<li>父组件 beforeCreate → 父组件 created → 父组件 beforeMount → 子组件 beforeCreate → 子组件 created → 子组件 beforeMount → 子组件 mounted → 父组件 mounted</li>
</ul>
<p>更新过程：</p>
<ul>
<li>父组件 beforeUpdate → 子组件 beforeUpdate → 子组件 updated → 父组件 updated</li>
</ul>
<p>销毁过程：</p>
<ul>
<li>父组件 beforeDestory → 子组件 beforeDestory → 子组件 destroyed → 父组件 destoryed</li>
</ul>
<h4 id="created-和-mounted-的区别"><a href="#created-和-mounted-的区别" class="headerlink" title="created 和 mounted 的区别"></a>created 和 mounted 的区别</h4><ul>
<li>created：在模板渲染成 html 前调用，通常初始化某些属性值，然后再渲染成视图</li>
<li>mounted：在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作</li>
</ul>
<h4 id="一般再哪个生命周期请求异步数据"><a href="#一般再哪个生命周期请求异步数据" class="headerlink" title="一般再哪个生命周期请求异步数据"></a>一般再哪个生命周期请求异步数据</h4><ul>
<li>一般可以再 created、beforeMount、mounted 中进行调用，因为这三个钩子函数中，data已经创建出来了，可以将服务端返回的数据进行赋值操作</li>
<li>推荐在 created 钩子函数中调用异步请求，因为能够更快的获取到服务端的数据，减少页面加载时间，用户体验更好</li>
</ul>
<h4 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h4><p>首先 keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存 —— 在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。</p>
<ul>
<li>如果为了一个组件包裹了 keep-alive，那么它会多出现两个生命周期：deactivated,activated。同时，beforeDestroy 和 destroyed 就不会再触发了，因为组件不会被真正的销毁。</li>
<li>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数</li>
</ul>
<h3 id="路由的-hash-和-history-模式的区别"><a href="#路由的-hash-和-history-模式的区别" class="headerlink" title="路由的 hash 和 history 模式的区别"></a>路由的 hash 和 history 模式的区别</h3><p>Vue-Router 有两种模式：hash模式 和 history模式。默认的路由模式是 hash模式</p>
<ul>
<li>hash模式 是开发中默认的模式，它的URL带着一个 # <ul>
<li>特点是 hash值会出现在 URL 里，但是不会出现在 HTTP 请求中，对后端没有影响。所以改变 hash 值，不会重新加载页面。</li>
</ul>
</li>
<li>history模式 的URL没有#，它使用的是传统路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个 URL，然后做出相应的逻辑处理<ul>
<li>特点是使用 history模式 时，URL更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回 404.</li>
</ul>
</li>
</ul>
<h4 id="hash和history的对比"><a href="#hash和history的对比" class="headerlink" title="hash和history的对比"></a>hash和history的对比</h4><ul>
<li>调用 history.pushState() 相比于直接修改hash，存在以下优势<ul>
<li>pushState() 设置的新 URL 可以是与当前 URL 同源任意 URL；而 hash 只可修改 # 后边的部分，因此只能设置与当前 URL 同文档的 URL</li>
</ul>
</li>
</ul>
<h4 id="Vue-router-跳转-和-location-href-有什么区别？"><a href="#Vue-router-跳转-和-location-href-有什么区别？" class="headerlink" title="Vue-router 跳转 和 location.href 有什么区别？"></a>Vue-router 跳转 和 location.href 有什么区别？</h4><ul>
<li><p>使用 location.href 跳转，简单方便，但是刷新了页面</p>
</li>
<li><p>使用 vue 路由跳转不需要刷新页面，静态跳转页面</p>
</li>
</ul>
<h3 id="Vuex-的原理"><a href="#Vuex-的原理" class="headerlink" title="Vuex 的原理"></a>Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。Vuex 应用的核心就是 store 仓库，也就是一个容器，它包含着应用中大部分的状态（state）。Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
<h4 id="Vuex有哪几种属性"><a href="#Vuex有哪几种属性" class="headerlink" title="Vuex有哪几种属性"></a>Vuex有哪几种属性</h4><ul>
<li>actions：包裹mutations，使之异步</li>
<li>mutations：提交更改数据的方法，同步</li>
<li>state：基本数据</li>
<li>getters：从基本数据派生出来的数据</li>
<li>module：模块化Vuex</li>
</ul>
<h4 id="Vuex-和-localStorage-的区别"><a href="#Vuex-和-localStorage-的区别" class="headerlink" title="Vuex 和 localStorage 的区别"></a>Vuex 和 localStorage 的区别</h4><ul>
<li>最重要的区别是 vuex存储在内存中，而 localStorage 则以文件的方式存储在本地。vuex是 vue的状态管理工具，用于组件之间的传值，localStorage 是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用。vuex能做到数据的响应式，localStorage 不能。vuex在刷新页面时存储的值会丢失，localStorage不会。对于不变的数据可以用localStorage代替vuex，但是当两个组件共用一个数据源（对象、数组）时，如果其中一个组件改变了该数据源，希望另一个组件也响应变化，localStorage是无法做到的。</li>
</ul>
<h4 id="为什么要用vuex"><a href="#为什么要用vuex" class="headerlink" title="为什么要用vuex"></a>为什么要用vuex</h4><ul>
<li>因为传参的方法对于多层嵌套的组件会非常繁琐，并且对于兄弟组件间的状态传递没有办法，我们通常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上模式非常的脆弱，还会导致代码无法维护。所以需要把组件的共享状态抽离到管理工具 vuex 中。这种模式下，组件就会不管在哪个位置，都能获取状态或者触发行为。</li>
</ul>
<h4 id="为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="为什么 Vuex 的 mutation 中不能做异步操作？"></a>为什么 Vuex 的 mutation 中不能做异步操作？</h4><ul>
<li>mutation是vuex中所有状态更新的唯一途径，异步操作通过 action 来提交 mutation 实现，这样可以方便跟踪每一个状态的变化。如果 mutation 支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的跟踪，给调试带来困难。</li>
</ul>
<h4 id="Vue3-0和Vue2-0的区别"><a href="#Vue3-0和Vue2-0的区别" class="headerlink" title="Vue3.0和Vue2.0的区别"></a>Vue3.0和Vue2.0的区别</h4><h5 id="响应式原理的变化"><a href="#响应式原理的变化" class="headerlink" title="响应式原理的变化"></a>响应式原理的变化</h5><ul>
<li>vue2的响应式原理是采用的 Object.defineProperty()方法对数据进行的劫持和发布订阅者模式的方式进行实现的。</li>
<li>Vue3则是用 es6 的 proxy 对数据进行代理，通过 reactive() 函数给每一个对象包一层 proxy，通过 Proxy 监听属性的变化来实现对数据的监控</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">Proxy的优点：可以直接监听对象的 添加删除属性，也可以直接监听数组的变化且 Proxy监听的是目标对象本身，不需要和 Object.defienProperty那样遍历每个属性，有一定的性能提升 </span></p>
</blockquote>
<h5 id="数据和方法的定义改变"><a href="#数据和方法的定义改变" class="headerlink" title="数据和方法的定义改变"></a>数据和方法的定义改变</h5><ul>
<li><p>Vue2使用的是选项型API,Vue3使用的是组合式API</p>
<blockquote>
<p><span style="color:#56c5ab">vue2的选项型API是在代码中分割成了不同的几个属性，如：data,computed,methods等。vue3的组合式API改变了这一点，利用了 function 来进行分割，使得代码看起来更加清晰简洁</span></p>
</blockquote>
</li>
<li><p>Vue3里利用setup函数作为属性和方法的入口</p>
</li>
</ul>
<h5 id="Vue2-0和Vue3-0的生命周期钩子的对应关系"><a href="#Vue2-0和Vue3-0的生命周期钩子的对应关系" class="headerlink" title="Vue2.0和Vue3.0的生命周期钩子的对应关系"></a>Vue2.0和Vue3.0的生命周期钩子的对应关系</h5><ul>
<li>beforeCreate 对应 setup()</li>
<li>create 对应 setup()</li>
<li>beforeMount 对应 onBeforeMount</li>
<li>mounted 对应 onMounted</li>
<li>beforeUpdate 对应 onBeforeUpdate</li>
<li>update 对应 onUpdate</li>
<li>beforeUnmount 对应 onBeforeUnmount</li>
<li>unmounted 对应 onUnmounted</li>
</ul>
<h5 id="Vue3移除了什么"><a href="#Vue3移除了什么" class="headerlink" title="Vue3移除了什么"></a>Vue3移除了什么</h5><ul>
<li>移除了 keyCode键盘的修饰符、.native修饰符、filter过滤器</li>
<li>不再建议使用mixins，因为组合式函数本身就是 mixin 更好的代替</li>
</ul>
<h3 id="Vue3-0带来了什么改变？"><a href="#Vue3-0带来了什么改变？" class="headerlink" title="Vue3.0带来了什么改变？"></a>Vue3.0带来了什么改变？</h3><ol>
<li>性能的提升（打包大小减少，初次渲染速度及更新渲染速度和内存的减少等……）</li>
<li>使用 proxy 代替 defineProperty 实现响应式，重写了 虚拟 DOM 的实现等……</li>
<li>Vue3.0 更好的支持 TypeScript</li>
<li>Vue3.0 采用了组合式 API （setup的配置）其中有 ref 与 reactive、watch 与 watchEffect、provide 与 inject 等。</li>
<li>Vue3.0新增了内置组件（Fragment，teleport,Suspense）</li>
<li>新的生命周期钩子、data选项始终被生命为一个函数、移除keyCode等。</li>
<li>Vue3.0的样式穿透 :deep取代了之前的 &#x2F;deep&#x2F; 和 ::v-deep</li>
</ol>
<h3 id="Vue3-0的响应式原理"><a href="#Vue3-0的响应式原理" class="headerlink" title="Vue3.0的响应式原理"></a>Vue3.0的响应式原理</h3><ul>
<li>通过 Proxy 代理拦截对象中属性的变化。（属性值的读写、属性的添加和删除等功能）</li>
<li>通过 Reflect 反射 对源对象的属性进行操作</li>
</ul>
<h3 id="Vue3有哪些响应判断函数？"><a href="#Vue3有哪些响应判断函数？" class="headerlink" title="Vue3有哪些响应判断函数？"></a>Vue3有哪些响应判断函数？</h3><blockquote>
<p><span style="color:#56c5ab">isRef、isReactive、isReadonly、isProxy这些响应判断函数</span></p>
</blockquote>
<ul>
<li>isRef 可以检查一个值是否是一个 ref 对象</li>
<li>isReactive 可以检查一个对象是否是 reactive 创建的响应式代理对象</li>
<li>isReadonly 可以检查一个对象是否是 readonly  创建的只读代理对象</li>
<li>isProxy 可以检查一个对象是否是 reactive 或 readonly 方法创建的代理对象</li>
</ul>
<h3 id="ref-和-reactive-的区别"><a href="#ref-和-reactive-的区别" class="headerlink" title="ref 和 reactive 的区别"></a>ref 和 reactive 的区别</h3><ul>
<li>ref通常是用来定义 基本数据类型 的，reactive是用来定义 对象或者数组这些类型的</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">ref也可以用来定义对象或者数组类型，它内部会自动通过 reactive 转换为代理对象</span></p>
</blockquote>
<ul>
<li>ref 操作数据需要 .value 取值，template模板中不需要 .value。reactive 都不需要 .value进行取值</li>
<li>解构赋值的情况下 reactive 会丢失响应，ref不会</li>
<li>ref是通过 Object.defineProperty() 的 get 和 set 实现的响应式。reactive 通过 Proxy实现的响应式，并且通过 Reflect 操作源对象内部的数据</li>
</ul>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="JavaScript-有哪些数据类型，它们的区别？"><a href="#JavaScript-有哪些数据类型，它们的区别？" class="headerlink" title="JavaScript 有哪些数据类型，它们的区别？"></a>JavaScript 有哪些数据类型，它们的区别？</h3><ul>
<li>JavaScript共有八种数据类型，分别是 Undefiend、Null、Boolean、Number、String、Object、Symbol、BigInt。<ul>
<li>Symbol 和 BigInt 是 ES6 新增的数据类型<ul>
<li>Symbol  类型 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突问题</li>
<li>BigInt 类型 是一种数字类型的数据，它可以表示任意精度格式的整数，它可以安全地存储和操作大整数，即使这个数已经超过了 Number 能够表示的安全整数范围。</li>
</ul>
</li>
<li>基本数据类型（栈）<ul>
<li>Undefined、Null、Boolean、Number、String</li>
</ul>
</li>
<li>引用数据类型（堆）<ul>
<li>Object,Array,function</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据类型的检测方式有哪些？"><a href="#数据类型的检测方式有哪些？" class="headerlink" title="数据类型的检测方式有哪些？"></a>数据类型的检测方式有哪些？</h3><ol>
<li><p>typeof</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">// number</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;string&#x27;</span>); <span class="comment">// string</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) <span class="comment">// function</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;) <span class="comment">// object</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">// object</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>



<ul>
<li>除了数组对象和null都会被判断为object，其他判断都正确</li>
</ul>
</li>
<li><p>instanceof </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">// false</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// false</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;string&#x27;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">// false</span></span><br><span class="line">   </span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// true</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<ul>
<li>正确判断对象的类型，其内部运行机制是在判断原型链中是否能找到该类型的原型</li>
<li>它只能判断引用数据类型，不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</li>
</ul>
</li>
<li><p>constructor</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="literal">true</span>).<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="string">&#x27;str&#x27;</span>).<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(([]).<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((&#123;&#125;).<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>它有两个作用，一是判断数据的类型，二是对象实例通过 constructor 对象访问它的构造函数。需要注意的是，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>()</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Fn</span>) <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Array</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Null-和-Undefined-的区别"><a href="#Null-和-Undefined-的区别" class="headerlink" title="Null 和 Undefined 的区别"></a>Null 和 Undefined 的区别</h3><ul>
<li>Undefined 和 Null 都是基本数据类型，这两个基本数据类型的值分别是 undefined 和 null<ul>
<li>Undefined 代表的是未定义，null 代表的是空对象。一般变量声明了但还没有定义时候会返回undefined，null主要用于赋值给一些可能返回对象的变量，作为初始化</li>
</ul>
</li>
</ul>
<h3 id="Object-is-与-比较操作符-x3D-x3D-x3D-、-x3D-x3D-的区别"><a href="#Object-is-与-比较操作符-x3D-x3D-x3D-、-x3D-x3D-的区别" class="headerlink" title="Object.is() 与 比较操作符 &#x3D;&#x3D;&#x3D;、 &#x3D;&#x3D; 的区别"></a>Object.is() 与 比较操作符 &#x3D;&#x3D;&#x3D;、 &#x3D;&#x3D; 的区别</h3><ul>
<li>使用双等（&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，则会进行强制类型转换后进行比较。</li>
<li>使用三等（&#x3D;&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，不会进行强制类型转换，直接返回false</li>
<li>Object.is()进行相等判断时，一般情况下和三等号的判断相同。它处理了一些特殊情况，比如 -0 和 +0 不再相等，两个NAN是相等的</li>
</ul>
<h3 id="如何判断一个对象是空对象"><a href="#如何判断一个对象是空对象" class="headerlink" title="如何判断一个对象是空对象"></a>如何判断一个对象是空对象</h3><ul>
<li>使用 JSON.stringify 方法判断：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj) == <span class="string">&quot;&#123;&#125;&quot;</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空对象&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 ES6 新增的方法 Object.keys() 判断：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="property">length</span> &lt; <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;空对象&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="箭头函数的-this-指向哪里？"><a href="#箭头函数的-this-指向哪里？" class="headerlink" title="箭头函数的 this 指向哪里？"></a>箭头函数的 this 指向哪里？</h4><ul>
<li>箭头函数没有属于自己的 this，它所谓的 this 是捕获其所在的上下文的 this 值，作为自己的 this 值，并且因为没有自己的 this，所以是不会被 new 调用的。这个所谓的 this 也不会被改变</li>
</ul>
<h3 id="扩展运算符的作用及使用场景"><a href="#扩展运算符的作用及使用场景" class="headerlink" title="扩展运算符的作用及使用场景"></a>扩展运算符的作用及使用场景</h3><ol>
<li><p>对象扩展运算符</p>
<ul>
<li>对象的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象中</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">注意点：扩展运算符对对象实例的拷贝属于浅拷贝</span></p>
</blockquote>
</li>
<li><p>数组扩展运算符</p>
<ul>
<li>数组的扩展运算符可以将一个数组转换为用逗号分隔的参数，且每次只能展开一层</li>
</ul>
</li>
<li><p>数组扩展运算符的应用：</p>
<ol>
<li>将数组转换为参数序列</li>
<li>复制数组</li>
<li>合并数组</li>
</ol>
</li>
</ol>
<ul>
<li><p>常见的应用场景是可以将某些数据结构转为数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//arguments对象</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用于替换 es5 中的 Array.prototype.slice.call(arguments)写法。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 Math 函数获取数组中特定的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">9</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers) <span class="comment">// 1</span></span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">max</span>(...numbers) <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Proxy-可以实现什么功能"><a href="#Proxy-可以实现什么功能" class="headerlink" title="Proxy 可以实现什么功能"></a>Proxy 可以实现什么功能</h3><blockquote>
<p><span style="color:#56c5ab">在 Vue3.0 中通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式</span></p>
</blockquote>
<h3 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h3><ul>
<li>DOM 指的是文档对象模型，它指的是把文档看成一个对象，这个对象主要定义了处理网页内容的方法和接口</li>
<li>BOM 指的是浏览器对象模型，它指的是把浏览器当成一个对象，这个对象主要定义了与浏览器进行交互的方法和接口</li>
</ul>
<h3 id="ES6-模块与-CommonJs-模块有什么异同？"><a href="#ES6-模块与-CommonJs-模块有什么异同？" class="headerlink" title="ES6 模块与 CommonJs 模块有什么异同？"></a>ES6 模块与 CommonJs 模块有什么异同？</h3><ul>
<li>ES6 Module 和 CommonJS 模块的区别<ul>
<li>CommonJs 是对模块的浅拷贝，ES6 Module 是对模块的引用，ES6 Module 只存只读，不能改变其值，也就是指针指向不能改变，类似 const；import 的接口是 read-only（只读状态），不能修改其变量值。即不能修改其变量的指针方法，但可以改变变量内部指针指向，可以对 commonjs 对重新赋值（改变指针指向），但对 ES6 Module 赋值会编译报错</li>
</ul>
</li>
<li>共同点<ul>
<li>Commonjs 和 ES6 Module 都可以对引入的对象进行赋值，即对对象内部属性的值进行改变。</li>
</ul>
</li>
</ul>
<h3 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a><strong>for…in 和 for…of 的区别</strong></h3><blockquote>
<p><span style="color:#56c5ab">for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</span></p>
</blockquote>
<h3 id="Axios特点"><a href="#Axios特点" class="headerlink" title="Axios特点"></a>Axios特点</h3><blockquote>
<p><span style="color:#56c5ab">Axios 是一种基于 Promise 封装的 HTTP 客户端</span></p>
</blockquote>
<ul>
<li>浏览器端发起 XMLHttpRequests 请求</li>
<li>node 端发起 http 请求</li>
<li>支持 Promise API</li>
<li>监听请求和返回</li>
<li>对请求和返回进行转换</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持抵御 XSRF 攻击</li>
</ul>
<h3 id="对原型和原型链的理解"><a href="#对原型和原型链的理解" class="headerlink" title="对原型和原型链的理解"></a>对原型和原型链的理解</h3><ul>
<li>在 JS 中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在ES5中这个指针被称为对象的原型。但是现在浏览器中实现了 <strong>proto</strong> 属性来访问这个属性，但最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</li>
<li>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建对象为什么能够使用 toSting() 等方法的原因。</li>
<li>特点：JS 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</li>
</ul>
<h3 id="原型链的终点是什么？如何打印出原型链的终点？"><a href="#原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="原型链的终点是什么？如何打印出原型链的终点？"></a>原型链的终点是什么？如何打印出原型链的终点？</h3><ul>
<li>由于 Object 是构造函数，所以原型链的终点是 Object.prototype.<strong>proto</strong>,而 Object.prototype.<strong>proto</strong> &#x3D;&#x3D;&#x3D; null 返回的是一个true,所以原型链的终点是 null。原型链上的所有原型都是对象，所有的对象最终都是由 Object 构造的，而Object.prototype 的下一级是 Object.prototype.__proto__。<img src="/images/面试题/原型最终指向.png" /></li>
</ul>
<h3 id="对作用域、作用域链的理解"><a href="#对作用域、作用域链的理解" class="headerlink" title="对作用域、作用域链的理解"></a>对作用域、作用域链的理解</h3><ol>
<li><p>全局作用域和函数作用域</p>
<ul>
<li>全局作用域理解<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域，所有未定义直接复制的变量自动声明为全局作用域。所有 window 对象的属性拥有全局作用域</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">注意点：全局作用域有很大的弊端，过多地全局作用域变量会污染全局命名空间，容易引起命名冲突</span></p>
</blockquote>
<ul>
<li>函数作用域理解<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到。</li>
<li>作用域是分层次的，内层作用域可以访问到外层作用域，反之不行</li>
</ul>
</li>
</ul>
</li>
<li><p>块级作用域</p>
<ul>
<li>使用 ES6 新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由 {} 包裹的代码片段）</li>
<li>let 和 const 声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
</li>
</ol>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><ul>
<li>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到 window 对象就被终止，这一层层的关系就是作用域链。</li>
<li>作用域链的作用是保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</li>
</ul>
<h3 id="对this的理解"><a href="#对this的理解" class="headerlink" title="对this的理解"></a>对this的理解</h3><ul>
<li><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的执行可以通过四种调试模式来判断，分别是：</p>
<ul>
<li>第一种是函数调用模式，当一个函数不是一个对象的属性时，直接作为函数来调用，this 指向这个对象</li>
<li>第二种是方法调用模式，当一个函数作为一个对象的方法来调用时， this 指向这个对象</li>
<li>第三种是构造器调用模式，如果一个函数被 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象</li>
<li>第四种是 apply、call 和 bind 调用模式，这三个方法都可以显示的指定调用函数的 this 指向。</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">这四种方式的优先级是 构造器(new)调用 &gt; 显示绑定(apply,call,bind) &gt; 方法调用 &gt; 函数调用</span></p>
</blockquote>
</li>
</ul>
<h3 id="call-和-apply-的区别？"><a href="#call-和-apply-的区别？" class="headerlink" title="call() 和 apply() 的区别？"></a>call() 和 apply() 的区别？</h3><ul>
<li>首先它们的作用是相同的，区别在于传参的形式不同<ul>
<li>apply 接收两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个下标的集合，这个集合可以是数组，也可以是类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数</li>
<li>call 传入的参数数量不固定，第一个参数和 apply 相同，第二个参数开始，每个参数被依次传入函数（逗号分隔）</li>
</ul>
</li>
</ul>
<h3 id="异步编程的实现方式？"><a href="#异步编程的实现方式？" class="headerlink" title="异步编程的实现方式？"></a>异步编程的实现方式？</h3><p>JS 中的异步机制可以分为以下几种</p>
<ul>
<li>回调函数 的方式可以实现，缺点是多个回调函数嵌套时会造成回调地狱，不利于代码维护</li>
<li>Promise 的方式，使用 Promise 的方式可以将嵌套函的回调函数作为链式调用。使用这种方式会导致出现多个 then 的链式调用，会造成代码的语义化不清晰</li>
<li>generator 的方式，使用这种方式 需要考虑何时将 函数的控制权转移回来。所以可以采用以下 Async 函数的方式：</li>
<li>async 函数的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句时，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变成 resolve 后再继续往下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行</li>
</ul>
<h3 id="对-Promise-的理解"><a href="#对-Promise-的理解" class="headerlink" title="对 Promise 的理解"></a>对 Promise 的理解</h3><p>Promise 是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，避免了回调地狱。简单说 promise是一个容器，里面保存着一个未来才会结束的事件的结果。</p>
<ul>
<li>promise 的三个状态：pending（等待中），resolved（已完成），rejected（已拒绝）<ul>
<li>当把一件事情交给 promise 时，它的状态就是 pending，任务完成了状态就变成了 resolved、失败了就变成 rejected</li>
</ul>
</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">特点：对象的状态是不受外界影响的，只有异步操作的结果，任何其他操作无法改变这个状态</span></p>
<p><span style="color:#56c5ab">缺点：无法取消 Promise，一旦新建他就会立即执行，无法中途取消。如果不设置回调函数，Promise 内部抛出的错误不会反应到外部。处于pending状态时，无法得知目前进展到哪一个阶段</span></p>
</blockquote>
<p>Promise 解决了回调地狱的问题</p>
<h3 id="async-x2F-await-对比-Promise-的优势"><a href="#async-x2F-await-对比-Promise-的优势" class="headerlink" title="async &#x2F; await 对比 Promise 的优势"></a>async &#x2F; await 对比 Promise 的优势</h3><p>async&#x2F;await是一个语法糖，代码读起来更加同步，Promise 虽然摆脱了回调地狱，但是 then 的</p>
<p>链式调⽤也会带来额外的阅读负担，async&#x2F;await⼏乎是同步的写法，⾮常优雅，错误的处理也非常的友好，</p>
<p>调试起来也更加方便。 </p>
<h2 id="Http协议"><a href="#Http协议" class="headerlink" title="Http协议"></a>Http协议</h2><h4 id="什么是Http协议？"><a href="#什么是Http协议？" class="headerlink" title="什么是Http协议？"></a>什么是Http协议？</h4><ul>
<li>Http协议是超文本传输协议，本身是tcp&#x2F;ip协的一个子集，在五层协议中位于应用层，三次握手，dns协议</li>
</ul>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><blockquote>
<p><span style="color:#56c5ab">其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</span></p>
</blockquote>
<ul>
<li><strong>第一次握手</strong>：客户端向服务端发包，服务端成功接收，服务端就能确认：服务端的接收和客户端的发送都没有问题</li>
<li><strong>第二次握手</strong>：服务端向客户端发包，客户端成功接收，客户端就可以确认：客户端的发送和接收能力、服务端的发送和接收能力都是没问题的</li>
<li>第三次握手：客户端发包，结束通信，服务端成功收到，服务端就可以确认：服务端的接收能力和发送能力；客户端的接收能力和发送能力都没有问题。</li>
</ul>
<blockquote>
<p><span style="color:#56c5ab">双方确认了自己的接收、发送能力是正常安全的后就可以正常进行通信了</span></p>
</blockquote>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>第一次挥手：客户端发起关闭连接的请求给服务端</li>
<li>第二次挥手：服务端收到关闭请求时可能数据还没有发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想关闭连接了，但是可能数据还没传输完毕，所以还需要等待</li>
<li>第三次挥手：当数据传输完事了，服务端还会主动发送一个报文（FIN），告诉客户端，表示数据发送完了，服务端这边准备关闭连接了</li>
<li>第四次挥手：当客户端收到服务端的报文（FIN）报文后，会回复一个报文（ACK），告诉服务端我知道了，再等待一会就关闭连接</li>
</ul>
<h4 id="http的请求方法及用途"><a href="#http的请求方法及用途" class="headerlink" title="http的请求方法及用途"></a>http的请求方法及用途</h4><ul>
<li>GET方法：发送一个请求来取得服务器上的某一资源</li>
<li>POST方法：向URL指定的资源提交数据或附加新的数据</li>
<li>PUT方法：跟POST方法比较像，也是向服务器提交数据。但是，它们之间是有不同的。PUT指定了资源在服务器上的位置，POST没有</li>
<li>DELETE方法：删除服务器上的某资源</li>
</ul>
<h4 id="post和get请求的区别"><a href="#post和get请求的区别" class="headerlink" title="post和get请求的区别"></a>post和get请求的区别</h4><ul>
<li>post请求的安全性会更高一些，比如不会作为url的一部分，也不会被缓存、它是保存在服务器的日志和浏览器记录中，get请求的是静态资源，所以会存在缓存。如果请求的是数据，就不会缓存</li>
<li>post请求发送的数据也会更大，get请求有url长度限制。</li>
<li>post请求能发送更多的数据类型</li>
<li>传参方式也不同（get请求参数是通过url拼接传递的，post请求是在body中进行传递</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>this优先级</title>
    <url>/2023/04/23/this%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<img src="/images/this背景.jpg"  />
<span id="more"></span>

<h2 id="this优先级"><a href="#this优先级" class="headerlink" title="this优先级"></a>this优先级</h2><h3 id="显示绑定高于隐式绑定"><a href="#显示绑定高于隐式绑定" class="headerlink" title="显示绑定高于隐式绑定"></a>显示绑定高于隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.call/apply的显示绑定高于隐式绑定</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">apply</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// abc</span></span><br><span class="line">obj.<span class="property">foo</span>.<span class="title function_">call</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.bind的优先级高于隐式绑定</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>.<span class="title function_">bind</span>(<span class="string">&quot;cba&quot;</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// cba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.更明显的比较</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo.<span class="title function_">bind</span>(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<h3 id="new高于隐式绑定和显示绑定"><a href="#new高于隐式绑定和显示绑定" class="headerlink" title="new高于隐式绑定和显示绑定"></a>new高于隐式绑定和显示绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new的优先级高于隐式绑定</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> obj.<span class="title function_">foo</span>() <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.<span class="property">foo</span>.<span class="title function_">bind</span>(<span class="string">&quot;aaa&quot;</span>) <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// foo</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p><span style="color:#56c5ab" >new绑定 &gt; 显示绑定(apply&#x2F;call&#x2F;bind) &gt; 隐式绑定(obj.foo()) &gt; 默认绑定(独立函数调用)</span></p>
</blockquote>
<h2 id="this特殊绑定"><a href="#this特殊绑定" class="headerlink" title="this特殊绑定"></a>this特殊绑定</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">foo.<span class="title function_">apply</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// apply/call/bind: 当传入null/undefined时, 自动将this绑定成全局对象</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>)</span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">bar</span>()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span></span><br><span class="line">&#125;; <span class="comment">// 代码规范问题，不加分号会认为和最后一行是一个整体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj2.bar = obj1.foo</span></span><br><span class="line"><span class="comment">// obj2.bar()</span></span><br><span class="line"></span><br><span class="line">(obj2.<span class="property">bar</span> = obj1.<span class="property">foo</span>)()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>this</category>
      </categories>
      <tags>
        <tag>this优先级</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流的理解及实现</title>
    <url>/2023/04/21/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<img src="/images/防抖节流.jpg" />
<span id="more"></span>

<h3 id="防抖：用户频发触发事件，只要最后一次事件的操作"><a href="#防抖：用户频发触发事件，只要最后一次事件的操作" class="headerlink" title="防抖：用户频发触发事件，只要最后一次事件的操作"></a>防抖：用户频发触发事件，只要最后一次事件的操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	input.<span class="property">oninput</span> = <span class="title function_">antiShake</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,<span class="number">500</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">function</span> <span class="title function_">antiShake</span>(<span class="params">fn,dealy</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  	<span class="keyword">let</span> t = <span class="literal">null</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">if</span>(t!==<span class="literal">null</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    	<span class="built_in">clearTimeout</span>(t)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    t = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    	fn.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;,dealy)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="节流则是控制事件高频率触发"><a href="#节流则是控制事件高频率触发" class="headerlink" title="节流则是控制事件高频率触发"></a>节流则是控制事件高频率触发</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;input&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">var</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>) </span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	input.<span class="property">oninput</span> = <span class="title function_">throttle</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,<span class="number">500</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">	<span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn,dealy</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  	<span class="keyword">let</span> flag = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    	<span class="keyword">if</span>(flag)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      	<span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        	fn.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">          flag = <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      flag = <span class="literal">false</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制流处理方式</title>
    <url>/2023/04/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81/</url>
    <content><![CDATA[<img src="/images/二进制流.png" />
<span id="more"></span>

<h3 id="处理后端接口返回的二进制流"><a href="#处理后端接口返回的二进制流" class="headerlink" title="处理后端接口返回的二进制流"></a>处理后端接口返回的二进制流</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 接口示例: config参数里传类型（responseType：blob）</span></span><br><span class="line"> <span class="attr">yxExcelExport</span>: <span class="function">(<span class="params">url: string,data: object</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> request.<span class="property">httpObj</span>.<span class="title function_">post</span>(url + <span class="string">&#x27;/v1/excel/yxExcelExport&#x27;</span>,data,&#123;<span class="attr">responseType</span>:  <span class="string">&#x27;blob&#x27;</span>&#125;);</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">createObjectURL</span>(res.<span class="property">data</span>) <span class="comment">// 将二进制文件转换为可访问的url</span></span><br><span class="line"> <span class="keyword">const</span> a = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"> <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(a)</span><br><span class="line"> a.<span class="property">href</span> = url</span><br><span class="line"> a.<span class="property">download</span> = <span class="string">&#x27;影像数据.xls&#x27;</span> </span><br><span class="line"> a.<span class="title function_">click</span>()</span><br><span class="line"> <span class="variable language_">window</span>.<span class="property">URL</span>.<span class="title function_">revokeObjectURL</span>(url)</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>处理后端接口返回的二进制流</tag>
      </tags>
  </entry>
  <entry>
    <title>vite和webpack的区别</title>
    <url>/2023/04/21/vite%E4%B8%8Ewebpack%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<img src="/images/vite与webpack.jpg"   />
<span id="more"></span>

<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p>一种新型前端构建工具，能够显著提升前端开发体验。它由两部分组成：</p>
<ul>
<li>开发服务器：它是基于 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">原生 ES 模块</a> 提供了  <a href="https://cn.vitejs.dev/guide/features.html">丰富的内建功能</a>，例如  <a href="https://cn.vitejs.dev/guide/features.html#hot-module-replacement">模块热更新（HMR）</a> </li>
<li>一套构建指令，它基于 <a href="https://rollupjs.org/">Rollup</a> 打包代码，并且是预配置的，可输出于生产环境的高度优化过的静态资源</li>
</ul>
<p>Vite 提供开箱即用的配置，同时它的  <a href="https://cn.vitejs.dev/guide/api-plugin.html">插件 API</a>  和 <a href="https://cn.vitejs.dev/guide/api-javascript.html">JavaScript API</a> 带来了高度的可扩展性，并有完整的类型支持。</p>
<p><img src="/images/vite.png" alt="vite"></p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的 <em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 <a href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图(dependency graph)</a>，然后将你项目中所需的每一个模块组合成一个或多个 <em>bundles</em>，它们均为静态资源，用于展示你的内容。</p>
<p><img src="/images/webpack.png" alt="webpack"></p>
<h2 id="vite-和-webpack的区别"><a href="#vite-和-webpack的区别" class="headerlink" title="vite 和 webpack的区别"></a>vite 和 webpack的区别</h2><ul>
<li>vite 是一个快速构建工具，适用于小型项目和快速原型开发。它使用 ES模块作为开发模式，可以快速启动开发服务器，支持热更新和快速构建</li>
<li>webpack 是一个功能强大的构建工具，适用于大型项目和复杂的构建需求。它可以处理各种类型的文件，支持代码分割、懒加载、优化和压缩等功能，可以满足更多的构建需求</li>
<li>区别：Vite 和 Webpack都是 JavaScript 应用程序的构建工具，它们的共同目标都是将应用程序源代码转换为可部署的 JavaScript、HTML、CSS。<ul>
<li>构建方式<ul>
<li>Vite 是一种 “零配置” 构建工具，使用 Rollup 进行快速的开发环境构建，同时支持基于插件的定制。在开发模式下 Vite 使用 ES modules 来直接引入模块，而不是打包所有代码，因此启动时间非常快。生产模式下，Vite 会对所有模块进行打包和压缩</li>
<li>webpack 则需要一个配置文件来定义如何构建应用程序</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vite和webpack的区别</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm</title>
    <url>/2023/04/21/nvm/</url>
    <content><![CDATA[<img src="/images/nvm.jpg" />
<span id="more"></span>

<h2 id="nvm简介"><a href="#nvm简介" class="headerlink" title="nvm简介"></a>nvm简介</h2><p>nvm是node包管理工具，不同项目依赖的node会不相同，所以就需要在不同的项目下使用不同node版本</p>
<p>nvm就是一个比较方便的node管理工具，用来切换node版本</p>
<h2 id="nvm下载及安装"><a href="#nvm下载及安装" class="headerlink" title="nvm下载及安装"></a>nvm下载及安装</h2><h3 id="nvm下载"><a href="#nvm下载" class="headerlink" title="nvm下载"></a>nvm下载</h3><p>安装包下载地址: <a href="https://github.com/coreybutler/nvm-windows/releases">nvm下载地址</a>,windows系统下载nvm-setup.zip安装包<br><img src="/images/nvm/nvm1.png" alt="nvm"  /></p>
<h3 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h3><p>如果电脑之前存在node，先进行卸载，再解压nvm-setup.zip安装包，进入解压的文件夹，双击exe后缀文件进行安装</p>
<img src="/images/nvm/nvm2.png" alt="nvm"  />

<p>下面界面选择nvm安装的路径,</p>
<img src="/images/nvm/nvm3.png" alt="nvm安装" />

<p>下面是nodejs安装位置，尽量都在同一路径下</p>
<img src="/images/nvm/nvm4.png" alt="nvm安装" />

<p>安装完成后命令行输入 nvm -v查看版本，查看切换版本时候要使用管理员权限</p>
<img src="/images/nvm/nvm5.png" alt="nvm安装" >

<h3 id="nvm使用"><a href="#nvm使用" class="headerlink" title="nvm使用"></a>nvm使用</h3><img src="/images/nvm/nvm6.png" alt="nvm使用" >
]]></content>
      <categories>
        <category>前端</category>
        <category>nvm</category>
      </categories>
  </entry>
  <entry>
    <title>git</title>
    <url>/2023/04/21/git/</url>
    <content><![CDATA[<img src="/images/git.png"  />
<span id="more"></span>

<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>git init：初始化 Git 仓库</li>
<li>git clone：克隆远程 Git 仓库到本地</li>
<li>git pull：从远程仓库拉取代码</li>
<li>git add -A：添加文件到暂存区</li>
<li>git commit -m ‘提交信息’：提交暂存区文件到 Git 仓库</li>
<li>git push：推送代码到远程仓库</li>
<li>git status：查看仓库状态</li>
<li>git diff：查看工作区和暂存区的差异</li>
<li>git log：查看提交历史</li>
<li>git branch：查看本地分支列表</li>
<li>git remote：查看远程仓库信息</li>
</ul>
<h3 id="配置操作"><a href="#配置操作" class="headerlink" title="配置操作"></a>配置操作</h3><ul>
<li>git config：查看、添加或修改 Git 配置</li>
<li>git config –global user.name<username>：设置 Git 全局用户邮箱</li>
<li>git config –system：修改系统级别 Git 配置</li>
<li>git config –local：修改当前仓库 Git 配置</li>
<li>git config –unset：删除 Git 配置项</li>
</ul>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li>git branch：查看分支列表</li>
<li>git branch <branchname>：创建分支</li>
<li>git branch -d <branchname>：删除本地分支</li>
<li>git checkout：切换分支</li>
<li>git merge：合并分支</li>
<li>git merge –no-ff：合并分支并保留分支历史</li>
<li>git push <remote> – delete <branchname>：删除远程分支</li>
</ul>
<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ul>
<li>git reset：撤销暂存区的所有修改</li>
<li>git reset <filename>：撤销暂存区指定文件的修改</li>
<li>git checkout – <filename>：撤销工作区指定文件的修改</li>
<li>git revert <commit>：撤销指定提交的修改</li>
<li>git reset –hard：重置工作区、暂存区和 Git 仓库状态</li>
</ul>
<h3 id="暂存操作"><a href="#暂存操作" class="headerlink" title="暂存操作"></a>暂存操作</h3><ul>
<li>git stash：将未提交的修改保存到 Git 的 stash 中，以便之后恢复或者应用</li>
<li>git stash save “message”：将未提交的修改保存到 Git 的 stash 中，并为当前的 stash 设置一个描述信息。描述信息可以帮助我们更好理解 stash 中保存的内容</li>
<li>git stash list：列出所有保存在 stash 中的修改。每个 stash 都有一个唯一的标识符，可用来区分不同的 stash</li>
<li>git stash apply <stash> ：将指定的 stash 应用到当前分支中，但是不会删除该 stash。如果要删除该 stash，需要使用 git stash drop 命令</li>
<li>git stash pop：将最近保存的 stash 应用到当前分支中，并删除该 stash。</li>
<li>git stash drop <stash>：删除指定的 stash</li>
<li>git stash clear：删除所有的 stash</li>
<li>git stash branch <branchname>：基于 stash 创建一个新的分支，并将该 stash 应用到新的分支中。新分支包含了 stash 中的所有修改</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git常用命令</tag>
      </tags>
  </entry>
</search>
